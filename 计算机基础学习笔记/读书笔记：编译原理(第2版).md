---
title: 读书笔记：编译原理(第2版)
date: 2020-09-21 16:00:00
tags: 计算机底层
categories: 计算机底层
---

# 第1章：引论

程序设计语言是向人以及计算机描述计算过程的记号。如我们所知，这个世界依赖于程序设计语言，因为在**所有计算机上运行的所有软件都是用某种程序设计语言编写的**。但是，在一个程序可以运行**之前**，它首先需要被**翻译**成一种能够被计算机执行的形式。

完成这项翻译工作的软件系统称为**编译器**(compiler)。

本书介绍的是**设计和实现编译器的方法**。我们将介绍用于构建面向多种语言和机器的翻译器的一些基本思想。**编译器设计的原理和技术还可以用于编译器设计之外的众多领域**。因此，这些原理和技术通常会在一个计算机科学家的职业生涯中多次被用到。研究编译器的编写将沙及程序设计语言、计算机体系结构、形式语言理论、算法和软件工程。

在本章中，我们将介绍**语言翻译器的不同形式**，在高层次上概述一个典型编译器的结构，并讨论了程序设计语言和硬件体系结构的发展趋势。这些趋势将影响编译器的形式。我们还将介绍关于编译器设计和计算机科学理论的关系的一些事实，并给出编译技术在编译领域之外的一些应用。最后，我们将简单论述在我们研究编译器时需要用到的重要的程序设计语言概念。

## 语言处理器

简单地说，一个编译器就是一个**程序**，它可以**阅读以某一种语言(源语言)编写的程序**，并把该程序**翻译成为一个等价的、用另一种语言(目标语言)编写的程序**，参见图1-1。编译器的重要**任务**之一是报告**它在翻译过程中发现的源程序中的错误**。

![](读书笔记：编译原理(第2版)/01.png)

如果目标程序是一个**可执行的机器语言程序**，那么它就可以被用户调用，处理输入并产生输出。参见图1-2。

![](读书笔记：编译原理(第2版)/02.png)

**解释器**(interpreter)是另一种常见的语言处理器。**它并不通过翻译的方式生成目标程序**。从用户的角度看，解释器直接利用用户提供的输入执行源程序中指定的操作。参见图1-3。

![](读书笔记：编译原理(第2版)/03.png)

在把用户输入映射成为输出的过程中，**由一个编译器产生的机器语言目标程序通常比一个解释器快很多**。然而，**解释器的错误诊断效果通常比编译器更好，因为它逐个语句地执行源程序**。

[编译器和解释器之间有什么区别](https://zhuanlan.zhihu.com/p/26838993)

[编译器和解释器](https://juejin.im/post/6844903853805027335)

**例1.1**

Java语言处理器**结合了编译和解释过程**，如图1-4所示。一个**Java源程序**首先被**编译**成一个称为**字节码**(bytecode)的中间表示形式。然后由一个**虚拟机**对得到的字节码加以解释执行。这样安排的好处之一是在一台机器上编译得到的字节码可以在另一台机器上**解释执行**。通过网络就可以完成机器之间的迁移。

![](读书笔记：编译原理(第2版)/04.png)

为了更快地完成输入到输出的处理，有些被称为即时(just in time)编译器的Java编译器在运行中间程序处理输入的前一刻首先把字节码翻译成为机器语言，然后再执行程序。

如图1-5所示，除了编译器之外，创建一个可执行的目标程序还需要一些其他程序。一个源程序可能被分割成为多个模块，并存放于独立的文件中。把源程序聚合在一起的任务有时会由一个被称为预处理器(preprocessor)的程序独立完成。预处理器还负责把那些称为宏的缩写形式转换为源语言的语句。

然后，将**经过预处理的源程序作为输入传递给一个编译器**。编译器可能产生一个**汇编语言**程序作为其输出，因为汇编语言比较容易输出和调试。接着，这个汇编语言程序由称为**汇编器(assembler)**的程序进行处理，并生成可重定位的机器代码。

大型程序经常被**分成多个部分进行编译**，因此，可重定位的机器代码有必要和其他可重定位的目标文件以及库文件**连接到一起**，形成真正在机器上运行的代码。一个文件中的代码可能指向另一个文件中的位置，而**链接器(linker)**能够解决外部内存地址的问题。最后，**加载器(loader)**把**所有的可执行目标文件放到内存中执行**。

![](读书笔记：编译原理(第2版)/05.png)

**1.1节的练习**

![](读书笔记：编译原理(第2版)/06.png)

## 一个编译器的结构

到现在为止，我们把编译器看作一个黑盒子，它能够把源程序映射为在语义上等价的目标程序。如果把这个盒子稍微打开一点，我们就会看到这个映射过程由两个部分组成：**分析部分和综合部分**。

分析(analysis)部分**把源程序分解成为多个组成要素**，并在这些要素之上加上**语法结构**。然后，它使用这个结构来创建该源程序的一个中间表示。如果分析部分检查出源程序没有按照正确的语法构成，或者语义上不一致，它就必须提供有用的信息，使得用户可以按此进行改正。分析部分还会收集有关源程序的信息，并把信息存放在一个称为**符号表(symbol table)**的数据结构中。符号表将和中间表示形式一起传送给综合部分。

综合(synthesis)部分根据中间表示和符号表中的信息来构造用户期待的目标程序。分析部分经常被称为编译器的前端(front end)，而综合部分称为后端(back end)

如果我们更加详细地研究编译过程，会发现它顺序执行了一组步骤(phase)。每个步骤把源程序的一种表示方式转换成另一种表示方式。一个典型的把编译程序分解成为多个步骤的方式如图1-6所示。在实践中，多个步骤可能被组合在一起，而这些组合在一起的步骤之间的中间表示不需要被明确地构造出来。存放整个源程序的信息的符号表可由编译器的各个步骤使用。

有些编译器在**前端和后端之间**有一个与机器无关的**优化步骤**。这个优化步骤的目的是在中间表示之上进行转换，以便后端程序能够生成更好的目标程序。如果基于未经过此优化步骤的中间表示来生成代码，则代码的质量会受到影响。因为优化是可选的，所以图1-6中所示的两个优化步骤之一可以被省略。

![](读书笔记：编译原理(第2版)/07.png)

### 词法分析

编译器的第一个步骤称为词法分析（lexical analysis）或扫描（scanning），。词法分析器读入组成源程序的字符流，并且将它们组织成为有意义的词素（lexeme）的序列。对于每个词素，词法分析器产生如下形式的词法单元（token）作为输出：

~~~html
<token-name, attribute-value>
~~~

这个词法单元被传送给下一个步骤，即语法分析。在这个词法单元中，第一个分量token-name是一个由语法分析步骤使用的抽象符号，而第二个分量attribute-value向号表中关于这个词法单元的条目。符号表条目的信息会被语义分析和代码生成步骤使用。

比如，假设一个源程序包含如下的赋值语句

~~~javascript
position = initial + rate * 60  (1.1)
~~~

这个赋值语句中的字符可以组合成如下词素，并映射成为如下词法单元。这些词法单元将被传递给语法分析阶段。

![](读书笔记：编译原理(第2版)/08.png)

分隔词素的空格会被词法分析器忽略掉。

图1-7给出经过词法分析之后，赋值语句1.1被表示成如下的词法单元序列：

~~~javascript
<id,1> <=> <id,2> <+> <id,3> <*> <60>
~~~

在这个表示中，词法单元名`=`、`+`和`*`分别是表示赋值、加法运算符、乘法运算符的抽象符号。

> 从技术上讲，我们应该为语法单元60建立一个形如<number,4>的词法单元，其中4指向符号表中对应于整数60的条目。但是我们要到第2章中才讨论数字的词法单元。第3章将讨论建立词法分析器的技术。

![](读书笔记：编译原理(第2版)/09.png)

### 语法分析

编译器的第2个步骤称为语法分析（syntax analysis）或解析（parsing）。语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示。该中间表示给出了词法分析产生的词法单元流的语法结构。一个常用的表示方法是语法树（syntax tree），树中的每个内部结点表示一个运算，而该结点的子结点表示该运算的分量。在图1-7中，词法单元流（1.2）对应的语法树被显示为语法分析器的输出。

这棵树显示了赋值语句

~~~javascript
position = initial + rate * 60 
~~~

中各个运算的执行顺序。这棵树有一个标号为`*`的内部结点，<id，3>是它的左子结点，整数60是它的右子结点。结点<id，3>表示标识符rate。标号为`*`的结点指明了我们必须首先把rate的值与60相乘。标号为`+`的结点表明我们必须把相乘的结果和initial的值相加。这棵树的根结点的标号为`=`，它表明我们必须把相加的结果存储到标识符position对应的位置上去。这个运算顺序和通常的算术规则相同，即**乘法的优先级高于加法**，因此乘法应该在加法之前计算。

编译器的后续步骤使用这个**语法结构**来帮助分析源程序，并**生成目标程序**。在第4章，我们将使用上下文无关文法来描述程序设计语言的语法结构，并讨论为某些类型的语法自动构造高效语法分析器的算法。在第2章和第5章，我们将看到，语法制导的定义将有助于描述对程序设计语言结构的翻译。

### 语义分析

语义分析器（semantic analyzer）使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。它同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中间代码生成过程中使用。

语义分析的一个重要部分是类型检查（type checking）。编译器检查每个运算符是否具有匹配的运算分量。比如，很多程序设计语言的定义中要求一个数组的下标必须是整数。如果用一个浮点数作为数组下标，编译器就必须报告错误。

程序设计语言可能允许某些类型转换，这被称为自动类型转换（coercion）。比如，一个二元算术运算符可以应用于一对整数或者一对浮点数。如果这个运算符应用于一个浮点数和一个整数，那么编译器可以把该整数转换（或者说自动类型转换）成为一个浮点数。

图1-7中显示了一个这样的自动类型转换。假设position，initial和rate已被声明为浮点数类型，而词素60本身形成一个整数。图1-7中的语义分析器的类型检查程序发现运算符*被用于一个浮点数rate和一个整数60，在这种情况下，这个整数可以被转换成为一个浮点数。请注意，在图1-7中，语义分析器输出中有一个关于运算符inttofloat的额外结点。inttofloat明确地把它的整数参数转换为一个浮点数。类型检查和语义分析将在第6章中讨论。

### 中间代码生成

在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示。这些中间表示可以有多种形式。语法树是一种中间表示形式，它们通常在语法分析和语义分析中使用。

在源程序的语法分析和语义分析完成之后，很多编译器生成一个明确的低级的或类机器语言的中间表示。我们可以把这个表示看作是某个抽象机器的程序。该中间表示应该具有两个重要的性质：它应该易于生成，且能够被轻松地翻译为目标机器上的语言。

在第6章，我们将考虑一种称为三地址代码（three-address code）的中间表示形式。这种中间表示由一组类似于汇编语言的指令组成，每个指令具有三个运算分量。每个运算分量都像一个寄存器。图1-7中的中间代码生成器的输出是如下的三地址代码序列：

~~~javascript
t1 = inttofloat (60)
t2= id3 * t1
t3= id2 + t2
id1 = t3
~~~

关于三地址指令，有几点是值得专门指出的。首先，每个三地址赋值指令的右部最多只有一个运算符。因此这些指令确定了运算完成的顺序。在源程序1.1中，乘法应该在加法之前完成。第二，编译器应该生成一个临时名字以存放一个三地址指令计算得到的值。第三，有些三地址指令的运算分量的少于三个（比如上面的序列1.3中的第一个和最后一个指令）。

在第6章，我们将讨论在不同编译器中用到的主要中间表示形式。第5章将介绍语法制导翻译技术。这些技术在第6章中被用于处理典型程序设计语言构造进行类型检查和中间代码生成。这些程序设计语言构造包括：表达式、控制流构造和过程调用。

### 代码优化

![](读书笔记：编译原理(第2版)/10.png)

![](读书笔记：编译原理(第2版)/11.png)

![](读书笔记：编译原理(第2版)/12.png)

![](读书笔记：编译原理(第2版)/13.png)

![](读书笔记：编译原理(第2版)/14.png)

![](读书笔记：编译原理(第2版)/15.png)

![](读书笔记：编译原理(第2版)/16.png)

![](读书笔记：编译原理(第2版)/17.png)

